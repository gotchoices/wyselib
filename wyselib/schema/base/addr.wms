# Entity addresses
#------------------------------------------
# Copyright WyattERP all rights reserved
#TODO:
#- 
require base.tcl ../trigview.tcl

namespace eval base {
    def addr_pk		{addr_ent addr_seq}
    def addr_v_in	{addr_ent addr_spec city state pcode country addr_cmt prim active physical}
    def addr_v_up	[lremove $addr_v_in addr_ent]
    def addr_se		[concat $addr_pk $addr_v_up $glob::stampfn]
    def addr_local	{}
}

# Contains an entry for each address for an entity
#----------------------------------------------------------------
table base.addr {base.ent} {
    addr_ent	int		references base.ent on update cascade on delete cascade
  , addr_seq	int	      , primary key (addr_ent, addr_seq)
  , addr_spec	varchar		not null
  , active	boolean		not null default true
  , prim	boolean		default false constraint "!base.addr.CPA" check(case when active is false then prim is false end)
  , physical	boolean		not null default false
  , addr_cmt	varchar
 
  , city	varchar
  , state	varchar
  , pcode	varchar
  , country	varchar(3)	constraint "!base.addr.CCO" not null default 'US' references base.country on update cascade
    subst($glob::stamps)
    subst($base::addr_local)	-- locally defined columns
}

# Generate unique sequence for new address entry
#----------------------------------------------------------------
function base.addr_tf_seq() {base.addr} {
  returns trigger language plpgsql security definer as $$
    begin
        if new.addr_seq is null then
            select into new.addr_seq coalesce(max(addr_seq),0)+1 from base.addr where addr_ent = new.addr_ent;
        end if;
        return new;
    end;
$$;}
trigger base_addr_tr_seq {} {
    before insert on base.addr for each row execute procedure base.addr_tf_seq();
}


# Trigger on base.addr to make sure there is only one primary address
# -----------------------------------------------------------------
function base.addr_tf_biud() {base.addr} {
  returns trigger language plpgsql security definer as $$
    declare
        seq	int;
    begin
        if TG_OP = 'UPDATE' then
            if new.prim != old.prim then
                update base.addr set prim = false where addr_ent = new.addr_ent and addr_seq <> new.addr_seq and prim = true;
            end if;
        elsif TG_OP = 'INSERT' then
            if new.prim is true then
                update base.addr set prim = false where addr_ent = new.addr_ent and prim = true;
            end if;
        elsif TG_OP = 'DELETE' then
            if old.prim is true then
                select into seq addr_seq from base.addr where addr_ent = old.addr_ent and addr_seq <> old.addr_seq order by addr_seq desc limit 1;
                if FOUND then
                    update base.addr set prim = true where addr_ent = new.addr_ent and addr_seq = seq;
--                else					-- OK to delete last address
--                    raise exception '!base.addr.CPS';
                end if;
                return old;
            else 
		return old;
            end if;
        end if;
      return new;
    end;
$$;}
trigger base_addr_tr_biud {} {
    before insert or update or delete on base.addr for each row execute procedure base.addr_tf_biud();
}


# Base address view
#----------------------------------------------------------------
view base.addr_v {base.addr base.ent_v} {
    select eval(fld_list $base::addr_se a)
      , oe.std_name

    from	base.addr	a
    join	base.ent_v	oe	on oe.id = a.addr_ent;

    eval(trigview::insert base.addr_v base.addr $base::addr_v_in $base::addr_pk $glob::stampin);
    eval(trigview::update base.addr_v base.addr $base::addr_v_up $base::addr_pk $glob::stampup);
    eval(rule_delete base.addr_v base.addr $base::addr_pk);
} -grant {
    {entim	s {i u} d}
}

